plugins {
	id "architectury-plugin" version "3.4-SNAPSHOT"
	id "dev.architectury.loom" version "1.7-SNAPSHOT" apply false
	id "com.gradleup.shadow" version "8.3.0" apply false
	id "com.matthewprenger.cursegradle" version "1.4.0" apply false
	id "com.modrinth.minotaur" version "2.+" apply false
	id "minepkg-publish" version "latest.release" apply false
}

architectury {
	minecraft = rootProject.minecraft_version
}

allprojects {
	group = rootProject.maven_group
}

subprojects {
	apply plugin: 'dev.architectury.loom'
	apply plugin: 'architectury-plugin'
	apply plugin: 'maven-publish'

	base {
		archivesName = project.archives_base_name
	}

	repositories {
		maven { url "https://maven.shedaniel.me/" }
		maven { url "https://maven.terraformersmc.com/releases" }
		maven {
			name = "Modrinth"
			url = "https://api.modrinth.com/maven"
			content {
				includeGroup "maven.modrinth"
			}
		}
	}

	dependencies {
		minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
		mappings loom.layered {
			it.mappings("net.fabricmc:yarn:$rootProject.yarn_mappings:v2")
			it.mappings("dev.architectury:yarn-mappings-patch-neoforge:$rootProject.yarn_mappings_patch_neoforge_version")
		}
	}

	java {
		withSourcesJar()
		sourceCompatibility = targetCompatibility = JavaVersion.toVersion(project.java_version as Integer)
	}

	tasks.withType(JavaCompile).configureEach {
		it.options.release = project.java_version as Integer
	}

	processResources {
		def stringProperties = providers.gradlePropertiesPrefixedBy('').get()
		stringProperties.each { inputs.property(it.key, it.value) }

		["*.mixins.json", "*.mod.json", "META-INF/mods.toml", "META-INF/neoforge.mods.toml"].each {
			filesMatching(it) {
				expand(stringProperties) {
					escapeBackslash = true
				}
			}
		}
	}

	def loader = project.name
	if (!enabled_platforms.split(',').contains(loader))
		return

	version = project.mod_version + "-" + loader +  "-" + project.minecraft_version

	def toList = (String s) -> s.split(',').collect{ it.trim() }

	def changesMd = rootProject.file('changes.md').exists() ? rootProject.file('changes.md').getText("UTF-8") : ''
	def projectGameVersions = toList(property("${loader}_game_version_list".toString()) as String)
	def capitalizedLoader = loader == 'neoforge' ? 'NeoForge' : loader.capitalize()

	apply plugin: "com.modrinth.minotaur"

	modrinth {
		def MODRINTH_TOKEN = System.getenv("MODRINTH_TOKEN")
		if (MODRINTH_TOKEN != null) {
			token = MODRINTH_TOKEN
			projectId = project.modrinth_id
			versionName = project.mod_version + "-" + loader
			versionNumber = project.mod_version
			versionType = "release"
			uploadFile = remapJar
			changelog = changesMd
			gameVersions = projectGameVersions
			loaders = [loader]
			dependencies {
				toList(project.modrinth_dependencies).each{ required.project(it) }
				if (loader == 'fabric') toList(project.modrinth_fabric_dependencies).each{ required.project(it) }
			}
		}
	}

	tasks.modrinth.dependsOn("build") // ensure finalizer to delete "header files" runs

	apply plugin: "com.matthewprenger.cursegradle"

	curseforge {
		def CURSEFORGE_TOKEN = System.getenv("CURSEFORGE_TOKEN")
		if (CURSEFORGE_TOKEN != null) {
			apiKey = CURSEFORGE_TOKEN
			project {
				id = project.curseforge_id
				releaseType = "release"
				changelogType = "markdown"
				changelog = changesMd

				addGameVersion capitalizedLoader
				projectGameVersions.each{ addGameVersion(it) }

				relations {
					toList(project.curseforge_dependencies).each{ requiredDependency(it) }
					if (loader == 'fabric') toList(project.curseforge_fabric_dependencies).each{ requiredDependency(it) }
				}
				mainArtifact(remapJar.archiveFile.get().asFile) {
					displayName = "${project.mod_version} [${capitalizedLoader} ${versionRange(projectGameVersions)}]"
				}
				afterEvaluate {
					uploadTask.dependsOn("build")
				}
			}
			options {
				forgeGradleIntegration = false
				javaVersionAutoDetect = false
			}
		}
	}

	if (loader != 'fabric')
		return

	apply plugin: "minepkg-publish"

	minepkg {
		def MINEPKG_TOKEN = System.getenv("MINEPKG_TOKEN")
		if (MINEPKG_TOKEN != null) {
			apiKey = MINEPKG_TOKEN
			artifact = remapJar
			platform = loader
			name = project.minepkg_id
			version = project.mod_version + "+" + project.minecraft_version
			license = "MIT"
			minecraftVersionRange = project.fabric_game_version_range
			toList(project.minepkg_dependencies).each{ require(it) }
		}
	}
}

static String versionRange(List<String> gameVersions) {
	if (gameVersions.size() == 1)
		return gameVersions[0]

	def versions = [gameVersions.first(), gameVersions.last()]
	def v = versions.collect { it.split('[.]') }
	def a = v.collect { it[0] as int }
	def b = v.collect {it.size() > 1 ? it[1] as int : 0 }
	def c = v.collect {it.size() > 2 ? it[2] as int : 0 }

	if (a[0] == a[1] && b[0] == b[1]) {
		if (c[1] - c[0] == 1) {
			// 1.21(.1)
			if (c[0] == 0)
				return "${a[0]}.${b[0]}(.${c[1]})"

			// 1.20.5/6
			return "${a[0]}.${b[0]}.${c[0]}/${c[1]}"
		}
	}

	return "${versions[0]} - ${versions[1]}"
}
